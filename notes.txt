Arrancamos la seccion de Azure DevOps. Seteamos cuentas y demas, y vamosa comenzar ahora.

Creamos el proyecto dentro de azure devops. 

Notese que dentro de aca se puede crear un repo, nosotros avmos a crear un repo en github.

Creamos el repo y despues simplemente pusheamos y tal,

git init
git add *
git add .
git add .gitignore
git commit -m "first commit"
git remote add origin https://github.com/julianbjornsson/azure-devops-kubernetes-terraform-pipeline.git
git push -u origin master

Seteado el repo, vamos a crear el pipeline:

Creamos el pipeline con el boton (es interactivo). El primer paso para crear el pipeline es elegir de donde se va a tomar el codigo, y nos 
da a elegir entre varios version control. Nosotros elegimos GIT (tiene uno que es Azure Git, que es por si creas el usuario de git desde 
Azure. Exacto, Azur te crea un par de credenciales para que puedas usar Git sin tu cuenta, digamos.) Luego hay que elegir el repo, te pide 
vincular la cuenta de azure con tu cuenta de github, te pregunta para instalar azure devops en tu github y una vez ahi, te 
detecta la configuracion basado en lo que tenes en el repo.

Entonces, en este caso detecta que tenemos un dockerfile en el repo, por ejemplo, y nos provee la posibilidad de configurar desde docker, 
k8s, etc. Vamos a hacer click en "Starter Pipeline", lo vamos a configurar con un YAML.

Lo primero que hacemos es cambiar e nombre. Por defecto, todos los pipelines que inicies en azure (o mas bien sus archivos yaml) se llaman 
azure-pipeline.yaml. Empezamos por renombrar ese default, y le damos a "save and run". Esto basicamente va a commitearlo, y nos da la opcion 
de escribir un mensaje de commit y por supuesto de elegir si queremos que vaya a la branch actual (master ne este caso ) o crear una nueva
Una vez aceptamos, se crea un JOB.

El job basicamente tiene una serie de pasos que se ejecutan, y azure lo hace automaticamente. Aca no cambiamos nada, asique esta toodo bien 
y el job inicia, hace todo y finaliza ok. Mas sobre JOBS y demas, en los proximos pasos.

A priori vemos que un job, es decir, esta ejecucion de pasos, se hace cada vez que commiteas codigo. Recien updateamos el yaml creado por 
azure, y commiteamos, y al pushearlo vemos que en azure devops se crea otro job. Es decir, el job se crea cuando se hace run en el pipeline,
y a su vez, cuando se commitea, se hace run, con lo cual se crea el job.

Ahora, analizando el archivo yaml de a partes, vemos que lo primero es:

trigger:
- master

El trigger lo que indica es "en que branch se corre el pipeline cuando ejecutamos el commit". Es decir... si el trigger no fuese master,
si estuviesemos trabajando en otra branch, y hacemos commit, con la configuracion de arriba no estariamos iniciando un run del pipeline, ya que 
solo estaria seteado para que triggeree en master. Podemos hacer run manualmente (manual triggering) desde azure devops para correr el pipeline.

pool:
  vmImage: 'ubuntu-latest'

Esto lo que hace es especificar el agente. QUe es el agente? basicamente es el tipo de maquin avirtual en la que se corre tu pipeline. Aca, 
estamos corriendo el pipeline en una vm de ubuntu, con la ultima version. Podes configurar desde aca que tipo de maquina queres que corra el 
pipeline, si windows o lo que sea. El pool de agentes que estamos usando es el de azure, pero tranquilamente podes usar servidores propios, 
lo cual tenes que configurar en la opcion "Agents", en el project settings.

El proximo paso, son los pasos que queres ejecutar ne tu pipeline. Azure DevOps ofrece mucha flexibilida en cuanto a como corres tus pipelines.
Podes ordenar las cosas uqe queres correr en stages, jobs, o steps/tasks. Este es el que viene con el file que crea azure:

steps:
  -script: echo Hello, World!
   displayName: 'Run a one-line script'
  
  -script: |
    echo Add other tasks to build, test, and deploy your project.
    echo See https://aka.ms/yaml
  displayName: 'Run a multi-line script'

  Lo que vemos aca son tareas, las tareas son el elemento mas basico en azure pipelines y se estan implementando aca como steps.
  Se puede usar si queres steps y tasks como si fuesen sinonimos, son basicamente lo mismo. Vemos que la primer tarea es un one-line script 
  que corre un echo, y el 2do es un multi-line script, por lo que vemos que azure permite correr ambos tipos de scripts y que esta es la forma 
  correcta de hacerlo (que es, con el pipe despues del -script.)
  Es decir, para one line usas -script: y los pasos, y para multi line usas -script: |

En el pipeline, tenemos STAGES, que son basicamente bloques en los que haces algo especifico, podes tener un STAGE para buildear, otro para 
deployear a un entorno, otro para deployear a otro, etc. Cada STAGE esta compuesto por JOBS. Los jobs son, coo vimos antes, la ejecucion 
de una serie de steps(o tasks). Podes tener mas de un job para correr en una musma BUILD (me estoy refiriendo a build aca como correr los 
jobs y commitear el codigo con el boton run, puede que la definicion cambie). Para verlo graficao seria algo asi:

Pipeline ---> STAGES ---> JOBS ---> steps

Es importante remarcar que se pueden tener varios jobs en un mismo stage, en e mismo yaml. Como se usa? Hast ahora, tenemos esto:

trigger:
- master

pool:
  vmImage: 'ubuntu-latest'

steps:
- script: echo Hello, world, updated!
  displayName: 'Run a one-line script'

- script: |
    echo Add other tasks to build, test, and deploy your project.
    echo See https://aka.ms/yaml
  displayName: 'Run a multi-line script'

Para agregar un job, hay que usar otro atributo dentro del yaml. Entonces, agregamos y quedaria asi:

trigger:
- master

pool:
  vmImage: 'ubuntu-latest'


jobs:
- job: job1
  steps:
  - script: echo JOB1 - Hello, world, updated!
    displayName: 'Run a one-line script'

  - script: |
        echo Add other tasks to build, test, and deploy your project.
        echo See https://aka.ms/yaml
    displayName: 'Run a multi-line script'
- job: job2
  steps:
  - script: echo JOB 2!!
  displayName: 'Run a one-line script'


Entonces, vemos que solo agregamos la categoria jobs y empezamos a agregar ahi, con esa sintaxis (-job: jobname). AHora si, commiteamos y vemos 
como reacciona Azure ante <1 job. 

Lo importante que llevarse de aca es que observamos que Azure ejecuta cada job indiviudalmente. Te ejecuta uno, y hasta que no termina, el  
otro queda queued. Cuando lo ejecuta, lo hjace en otro agente (otro virtual server). 

Como haces para crear una dependencia entre jobs? es decir, que sea secuenciado de otra manera? con dependsOn.

Podes agregar dependsOn: jobname --> para decir que tal job no se ejecute hasta que se cumpla tal otro/otros jobs. Asi queda nuestro archivo:

NOTA: en azure devops y en la ejecucion salvo el job1 todos figuran como Run a one-line script, porque asi esta el displayName que me olvide 
de cambiar. Ahora lo modifique y lo comittee de nuevo y se ve bien.

jobs:
- job: job1
  steps:
  - script: echo JOB1 - Hello, world, updated!
    displayName: 'Run a one-line script'

  - script: |
        echo Add other tasks to build, test, and deploy your project.
        echo See https://aka.ms/yaml
    displayName: 'Run a multi-line script'
- job: job2
  dependsOn: job1
  steps:
  - script: echo JOB 2!!
  displayName: 'job2'
- job: job3
  dependsOn: job1
  steps:
  - script: echo JOB 3!!
  displayName: 'job3'
- job: job4
  dependsOn: 
  - job2
  - job3
  steps:
  - script: echo JOB 4!!
  displayName: 'job4'  

  Al ejecutarlo asi, el job 1 va a arrancar normalmente porque no tiene restriccion (y es el primero). El job 2 y el job 3 pueden arrancar 
  una vez el job 1 este listo (no antes), y el job 4 solo va a arrancar cuando el 2 y el 3 hayan terminado bien.

  